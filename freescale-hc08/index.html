<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta name="copyright" content="All content on www.nimblemachines.com is copyrighted. All rights are reserved." />
<meta name="keywords" content="Freescale, HC08, microcontroller, 8-bit" />
<meta name="robots" content="index,follow" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/-/screen.css" type="text/css" />
<link rel="canonical" href="https://www.nimblemachines.com/freescale-hc08/" />
<title>Freescale HC08 &ndash; Nimble Machines</title>
</head>
<body>

<div id="header">
<h1>Freescale HC08</h1>
<hr />
</div>

<div id="content">
<p>The <a href="http://www.freescale.com/webapp/sps/site/taxonomy.jsp?code=HC08FAMILY">HC08</a> is <a href="/freescale/">Freescale</a>'s previous generation 8-bit microcontroller family. It has been superseded by the <a href="/freescale-hcs08/">Freescale HCS08</a> (hereafter called simply <a href="/freescale-hcs08/">S08</a>), a superior family in every respect. No new design should be based on the HC08! Use the <a href="/freescale-hcs08/">S08</a> instead.</p>
<p>The HC08 is closely related to, and its instruction set is a superset of, <em>its</em> predecessor, the HC05. The HC08 improves upon the HC05 in the following ways:</p>
<ul>
<li>the Stack Pointer (SP) is 16-bits wide, so the stack can be anywhere in RAM, and can be bigger than 64 bytes (the maximum size on the HC05)</li>
<li>an 8-bit H register was added, which, concatenated with the 8-bit X register, can be used as a 16-bit pointer anywhere in the memory map; however, a 16-bit offset can be used with X, but this is not as efficient or flexible as having a true 16-bit pointer register</li>
<li>a handful of instructions (LDHX, STHX, CPHX, PSHH, PULH) were added to make using HX easier</li>
<li>an overflow (V) bit was added to the condition code register</li>
<li>signed branch instructions (BLT, BGE, BLE, BGT) &ndash; which require a V bit &ndash; were added</li>
</ul>
<p>I think that&rsquo;s about it, but that&rsquo;s a huge improvement. Computation and comparisons with signed numbers are supported, and the RAM and stack can be arbitrarily large; on the HC05 <em>both</em> the stack <em>and</em> the i/o ports had to fit into the first 256 byte page of memory.</p>
<p>Object code for the HC05 can run unchanged on an HC08 &ndash; assuming that the i/o ports are the same.</p>
<hr />
<h3 id="debugging-and-bootstrapping"><a href="#debugging-and-bootstrapping">Debugging and bootstrapping</a></h3>
<p>When I first started, in earnest, to explore the HC08 &amp; HCS08 and to build support for them into <a href="https://muforth.nimblemachines.com/">muforth</a>, I started out not with an S08 part, but an HC08 &ndash; in particular, the <a href="https://cache.freescale.com/files/microcontrollers/doc/data_sheet/MC68HC908QB8.pdf">MC908QB8</a>, of which I had several samples in a DIP 16 package. Unlike the S08 parts, which come blank from the factory and can only be programmed via the single-wire BDM debug interface, the HC08 parts come with a small ROM bootloader, and can be flashed over a clunky and slow half-duplex serial interface.</p>
<p>My first challenge was to get this interface working, then to get some code into the RAM and execute it, and finally to figure out how to program the flash memory. The code I ended up flashing was a combination &ldquo;debug stub&rdquo; and BDM-over-serial interface, so I could talk to the HC08 &ldquo;host&rdquo; more easily over the normal serial port &ndash; the bootloader interface is bitbanged on a normal i/o pin &ndash; and use it to program &ldquo;target&rdquo; S08 chips over their BKGD pin.</p>
<p>This went slowly, but eventually I was able to get the BDM code working and successfully programmed an <a href="/freescale-s08qg/">S08QG</a>8 chip &ndash; also a DIP 16, easily breadboardable part. Once I had code running on <em>that</em> chip &ndash; I programmed the same debug stub and BDM &ldquo;host&rdquo; code onto it that I was running on the 908QB8 &ndash; I could ignore the HC08 part &ndash; forever.</p>
<p>Which is just as well, because not only are they are <em>Not Recommended for New Designs</em> by Freescale, but they are no longer available in a DIP 16 package.</p>
<p>Ironically, not long after undergoing this arduous but extremely educational bootstrapping process, Freescale introduced the <a href="/freescale-s08js/">S08JS</a> family &ndash; a chip with a full-speed USB interface, and a USB bootloader in ROM. While not a DIP part, it comes in a not-impossible-for-mere-mortals-to-solder SOIC 20 package, and with the help of a <a href="http://www.dipmicro.com/store/PCB-PB1">prototyping board</a> from <a href="/dipmicro-electronics/">dipmicro</a> and my trusty Weller WTCPT iron, I was able to put together a board in short order. After understanding Freescale&rsquo;s USB bootloader protocol and writing support for it into muforth, I could now program the JS16 over USB, and because I had equipped it with a BDM &ldquo;host&rdquo; interface, I could use it to program other S08 chips. I had to be careful about voltages, however: the JS is a 5v part and most of the S08&rsquo;s I was trying to program with it (<a href="/freescale-s08qg/">S08QG</a> and <a href="/freescale-s08qe/">S08QE</a> parts, mostly) are 3v parts.</p>
<p>The good news in all this is that no-one needs to re-create the bootstrap process I went through with the 908QB8, and can instead jump directly into the world of the JS16. It&rsquo;s pretty easy to build a <a href="/js16-usb-board/">JS16 USB board</a>.</p>

</div>

<div id="footer">
<hr />
<a href="mailto:%77%65%62%68%61%6d%73%74%65%72%40%6e%69%6d%62%6c%65%6d%61%63%68%69%6e%65%73%2e%63%6f%6d?subject=%5bNimble%20Machines%5d%20Freescale%20HC08">Send feedback</a> on this page (last edited 2014 January 06 23:29)<br />
Browse <a href="/all-pages/">all pages</a>, or return <a href="/">home</a>
</div>

</body>
</html>
